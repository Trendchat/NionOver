<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Overdrive - Quad Shot Edition</title>
    <style>
        body { margin: 0; background: #020205; overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 25px; left: 25px; pointer-events: none; user-select: none; }
        .stat-box { background: rgba(0, 255, 255, 0.05); border-left: 4px solid #0ff; padding: 8px 15px; margin-bottom: 8px; backdrop-filter: blur(5px); }
        .label { color: rgba(0, 255, 255, 0.6); font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
        .value { color: #fff; font-size: 22px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        .high-score-val { color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        #health-container { width: 250px; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 10px; position: relative; }
        #health-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #0ff, #0088ff); border-radius: 4px; transition: 0.3s; box-shadow: 0 0 15px #0ff; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(5, 5, 15, 0.98); border: 2px solid #0ff; padding: 50px; text-align: center; display: none; border-radius: 10px; box-shadow: 0 0 100px rgba(0, 255, 255, 0.3); z-index: 100; }
        h1 { color: #fff; font-size: 50px; margin: 0; letter-spacing: 3px; }
        button { background: #0ff; border: none; color: #000; padding: 12px 35px; font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 25px; transition: 0.3s; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0 100%); }
        button:hover { background: #fff; transform: scale(1.05); }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="stat-box">
            <div class="label">Score</div>
            <div id="score" class="value">0000</div>
        </div>
        <div class="stat-box" style="border-left-color: #ff0055;">
            <div class="label">High Score</div>
            <div id="highScore" class="value high-score-val">0000</div>
        </div>
        <div class="stat-box">
            <div class="label">Level</div>
            <div id="level" class="value">1</div>
        </div>
        <div id="health-container"><div id="health-bar"></div></div>
    </div>
    <div id="game-over">
        <h1 id="status-text">GAME OVER</h1>
        <p style="color: #0ff; font-size: 20px;">Score: <span id="final-score">0</span></p>
        <p id="new-record" style="color: #ff0055; font-weight: bold; display: none;"> </p>
        <button onclick="location.reload()">REBOOT SYSTEM</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let score = 0;
        let level = 1;
        let health = 100;
        let gameActive = true;
        let shakeAmount = 0;
        let highScore = localStorage.getItem('neonHighScore') || 0;
        document.getElementById('highScore').innerText = highScore.toString().padStart(4, '0');

        const keys = { w: false, a: false, s: false, d: false };
        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

        // نظام المستودع (Memory Pooling) لضمان أداء مستقر للمعالج والرام
        const pools = { projectiles: [], enemies: [], particles: [] };

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.radius = 20;
                this.color = '#0ff';
                this.speed = 7;
            }
            draw() {
                ctx.save();
                ctx.shadowBlur = 30; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = "#fff"; ctx.fill();
                ctx.restore();
            }
            update() {
                if (keys.w && this.y > this.radius) this.y -= this.speed;
                if (keys.s && this.y < canvas.height - this.radius) this.y += this.speed;
                if (keys.a && this.x > this.radius) this.x -= this.speed;
                if (keys.d && this.x < canvas.width - this.radius) this.x += this.speed;
                this.draw();
            }
        }

        class Projectile {
            constructor() { this.active = false; }
            init(x, y, vx, vy) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.radius = 8; this.active = true;
            }
            draw() {
                ctx.save(); ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 20; ctx.shadowColor = '#0ff';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff'; ctx.fill(); ctx.restore();
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.active = false;
                this.draw();
            }
        }

        class Enemy {
            constructor() { this.active = false; }
            init(x, y, radius, color, velocity) {
                this.x = x; this.y = y; this.radius = radius;
                this.color = color; this.velocity = velocity;
                this.hp = Math.floor(radius / 6); this.active = true;
            }
            draw() {
                ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
            }
            update() {
                this.x += this.velocity.x; this.y += this.velocity.y;
                this.draw();
            }
        }

        class Particle {
            constructor() { this.active = false; }
            init(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 12; this.vy = (Math.random() - 0.5) * 12;
                this.alpha = 1; this.size = Math.random() * 4 + 2; this.active = true;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.alpha -= 0.015;
                if (this.alpha <= 0) this.active = false;
                ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        const player = new Player();
        const activeProjectiles = [];
        const activeEnemies = [];
        const activeParticles = [];

        function getFromPool(type) {
            let obj = pools[type].find(o => !o.active);
            if (!obj) {
                if (type === 'projectiles') obj = new Projectile();
                else if (type === 'enemies') obj = new Enemy();
                else if (type === 'particles') obj = new Particle();
                pools[type].push(obj);
            }
            return obj;
        }

        function spawnEnemy() {
            if(!gameActive) return;
            const radius = Math.random() * 30 + 10;
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -radius : canvas.width + radius;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -radius : canvas.height + radius;
            }
            const angle = Math.atan2(player.y - y, player.x - x);
            
            // سرعة متغيرة حسب المستوى (سريعة في البداية وتدريجية لاحقاً)
            let speed;
            if (level <= 7) {
                speed = Math.random() * 3 + (level * 0.7); 
            } else {
                speed = Math.random() * 3 + (7 * 0.7) + ((level - 7) * 0.12);
            }
            
            const enemy = getFromPool('enemies');
            enemy.init(x, y, radius, `hsl(${Math.random()*360}, 80%, 60%)`, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
            activeEnemies.push(enemy);
            
            // كثافة الأعداء (تخف بنسبة 30% من المستوى 7 فما فوق)
            let baseDelay = 2500 - (level * 180);
            if (level >= 7) {
                baseDelay = (2500 - (level * 140)) / 0.7; 
            }
            
            let spawnDelay = Math.max(700, baseDelay);
            setTimeout(spawnEnemy, spawnDelay);
        }

        window.onclick = (e) => {
            if(!gameActive) return;
            const angle = Math.atan2(e.clientY - player.y, e.clientX - player.x);
            
            const createShot = (ang) => {
                const p = getFromPool('projectiles');
                p.init(player.x, player.y, Math.cos(ang) * 15, Math.sin(ang) * 15);
                activeProjectiles.push(p);
            };

            // --- نظام النيران المطور ---
            if (level === 1) {
                createShot(angle); // طلقة واحدة
            } else if (level === 2) {
                createShot(angle - 0.05); // طلقتان ضيقتان
                createShot(angle + 0.05);
            } else if (level < 8) {
                createShot(angle); // ثلاث طلقات ضيقة
                createShot(angle - 0.08);
                createShot(angle + 0.08);
            } else {
                // المستوى الثامن فما فوق: 4 طلقات دفعة واحدة وبانتشار ضيق جداً
                createShot(angle - 0.12);
                createShot(angle - 0.04);
                createShot(angle + 0.04);
                createShot(angle + 0.12);
            }
            
            shakeAmount = 2;
        };

        function endGame() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonHighScore', highScore);
                document.getElementById('highScore').innerText = highScore.toString().padStart(4, '0');
                document.getElementById('new-record').style.display = 'block';
                document.getElementById('status-text').innerText = "NEW RECORD!";
                document.getElementById('status-text').style.color = "#ff0055";
            }
        }

        function animate() {
            if(!gameActive) return;
            requestAnimationFrame(animate);
            ctx.fillStyle = 'rgba(2, 2, 8, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (shakeAmount > 0) {
                ctx.save();
                ctx.translate(Math.random() * shakeAmount - shakeAmount/2, Math.random() * shakeAmount - shakeAmount/2);
                shakeAmount *= 0.9;
            }

            for (let i = activeParticles.length - 1; i >= 0; i--) {
                activeParticles[i].update();
                if (!activeParticles[i].active) activeParticles.splice(i, 1);
            }

            for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                activeProjectiles[i].update();
                if (!activeProjectiles[i].active) activeProjectiles.splice(i, 1);
            }

            player.update();

            for (let ei = activeEnemies.length - 1; ei >= 0; ei--) {
                const enemy = activeEnemies[ei];
                enemy.update();
                
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (dist < player.radius + enemy.radius) {
                    health -= 20;
                    shakeAmount = 30;
                    enemy.active = false;
                    activeEnemies.splice(ei, 1);
                    document.getElementById('health-bar').style.width = health + '%';
                    if(health <= 0) endGame();
                    continue;
                }

                for (let pi = activeProjectiles.length - 1; pi >= 0; pi--) {
                    const proj = activeProjectiles[pi];
                    const d = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                    if (d < enemy.radius + proj.radius) {
                        for(let i=0; i<10; i++) {
                            const part = getFromPool('particles');
                            part.init(enemy.x, enemy.y, enemy.color);
                            activeParticles.push(part);
                        }
                        proj.active = false;
                        activeProjectiles.splice(pi, 1);
                        enemy.hp--;
                        if(enemy.hp <= 0) {
                            score += 150;
                            if(score % 1500 === 0) {
                                level++;
                                document.getElementById('level').innerText = level;
                            }
                            document.getElementById('score').innerText = score.toString().padStart(4, '0');
                            enemy.active = false;
                            activeEnemies.splice(ei, 1);
                            shakeAmount = 10;
                            break;
                        }
                    }
                }
            }
            if (shakeAmount > 0) ctx.restore();
        }

        spawnEnemy();
        animate();
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
